generator client {
  provider        = "prisma-client"
  output          = "../prisma/generated"
  previewFeatures = ["queryCompiler", "driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model NewsLetterSubscriptions {
  id         String   @id @default(uuid(7)) @db.Uuid
  email      String   @unique
  created_at DateTime @default(now())

  @@map("newsletter_subscriptions")
}

enum KeyTypes {
  AES256
  X25519

  @@map("key_types")
}

model Keys {
  id                   String        @id @default(uuid(7)) @db.Uuid
  material             Bytes? // Encrypted key material (from wrapper key)
  public_material      Bytes? // Public key material for asymmetric keys
  private_material     Bytes? // Encrypted private key material (from wrapper key)
  type                 KeyTypes
  users_master_key     Users[]       @relation("master_key")
  users_asymmetric_key Users[]       @relation("asymmetric_master_key")
  server_files         ServerFiles[]
  folders              Folders[]
  created_at           DateTime      @default(now())

  @@map("keys")
}

model Users {
  id                       String               @id @default(uuid(7)) @db.Uuid
  username                 String               @db.VarChar(30) // Public display name
  email                    String               @unique
  password                 String // Hashed
  jwt_id                   Bytes // JWT ID for token revocation
  master_key_id            String               @db.Uuid // Optional master key ID for user-specific keys
  master_key               Keys                 @relation("master_key", fields: [master_key_id], references: [id], onDelete: Cascade)
  asymmetric_master_key_id String               @db.Uuid // Optional asymmetric key ID for user-specific keys
  asymmetric_master_key    Keys                 @relation("asymmetric_master_key", fields: [asymmetric_master_key_id], references: [id], onDelete: Cascade)
  avatars                  Avatars?
  email_verifications      EmailVerification?
  folders                  Folders[]
  files                    Files[]
  created_at               DateTime             @default(now())
  updated_at               DateTime             @updatedAt
  shopping_lists           ShoppingLists[]
  shopping_list_shares     ShoppingListShares[]
  family_members           FamilyMembers[]      @relation("family_owner")
  member_of_families       FamilyMembers[]      @relation("family_member")

  @@map("users")
}

model FamilyMembers {
  id        String @id @default(uuid(7)) @db.Uuid
  user_id   String @db.Uuid
  user      Users  @relation("family_owner", fields: [user_id], references: [id], onDelete: Cascade)
  member_id String @unique @db.Uuid
  member    Users  @relation("family_member", fields: [member_id], references: [id], onDelete: Cascade)

  @@unique([user_id, member_id])
  @@map("family_members")
}

model EmailVerification {
  id         String   @id @default(uuid(4)) @db.Uuid
  user_id    String   @unique @db.Uuid
  user       Users    @relation(fields: [user_id], references: [id], onDelete: Cascade)
  created_at DateTime @default(now())
  expires_at DateTime

  @@map("email_verifications")
}

model ServerFiles {
  id          String   @id @default(uuid(7)) @db.Uuid
  s3_key      String   @unique @db.Uuid
  checksum    String   @db.VarChar(64) // SHA-256 checksum for file integrity
  mime_type   String?  @db.VarChar(50) // Optional MIME type for the file
  file_key_id String   @db.Uuid // Encrypted file key (from master key)
  file_key    Keys     @relation(fields: [file_key_id], references: [id], onDelete: Cascade)
  iv          Bytes // Initialization vector for encryption
  auth_tag    Bytes // Authentication tag for encryption
  size        Int // Size in bytes
  avatar      Avatars?
  files       Files[]
  created_at  DateTime @default(now())

  @@map("server_files")
}

model Avatars {
  user_id        String      @id @db.Uuid
  user           Users       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  server_file_id String      @unique @db.Uuid
  server_file    ServerFiles @relation(fields: [server_file_id], references: [id], onDelete: Cascade)
  created_at     DateTime    @default(now())

  @@map("avatars")
}

enum FolderTypes {
  MEDIA

  @@map("folder_types")
}

model Folders {
  id            String       @id @default(uuid(7)) @db.Uuid
  user_id       String       @db.Uuid
  user          Users        @relation(fields: [user_id], references: [id], onDelete: Cascade)
  folder_key_id String       @db.Uuid // Encrypted folder key (from user key)
  folder_key    Keys         @relation(fields: [folder_key_id], references: [id], onDelete: Cascade)
  name          String       @db.VarChar(100)
  type          FolderTypes? // Optional type for special folders (e.g., media)
  parent_id     String?      @db.Uuid // Null for root folders
  parent        Folders?     @relation("folder_hierarchy", fields: [parent_id], references: [id], onDelete: Cascade)
  children      Folders[]    @relation("folder_hierarchy")
  files         Files[]
  created_at    DateTime     @default(now())
  updated_at    DateTime     @updatedAt

  @@unique([name, parent_id]) // Ensure unique folder names per parent
  @@unique([user_id, type]) // Ensure unique folder names per user and type
  @@map("folders")
}

model Files {
  id        String      @id @default(uuid(7)) @db.Uuid
  user_id   String      @db.Uuid
  user      Users       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  file_id   String      @db.Uuid
  file      ServerFiles @relation(fields: [file_id], references: [id], onDelete: Cascade)
  name      String      @db.VarChar(100)
  folder_id String?     @db.Uuid // Null for root files
  folder    Folders?    @relation(fields: [folder_id], references: [id], onDelete: Cascade)

  @@unique([name, folder_id]) // Ensure unique file names per folder
  @@map("files")
}

model ShoppingLists {
  id                   String               @id @default(uuid(7)) @db.Uuid
  user_id              String               @db.Uuid
  user                 Users                @relation(fields: [user_id], references: [id], onDelete: Cascade)
  shopping_list_items  ShoppingListItems[]
  shopping_list_shares ShoppingListShares[]
  shopping_list_cards  ShoppingListCards[]

  @@map("shopping_lists")
}

model ShoppingListItems {
  id               String        @id @default(uuid(7)) @db.Uuid
  shopping_list_id String        @db.Uuid
  shopping_list    ShoppingLists @relation(fields: [shopping_list_id], references: [id], onDelete: Cascade)
  name             String
  quantity         Int
  unit             String?
  is_purchased     Boolean       @default(false)

  @@map("shopping_list_items")
}

model ShoppingListCards {
  id               String        @id @default(uuid(7)) @db.Uuid
  shopping_list_id String        @db.Uuid
  shopping_list    ShoppingLists @relation(fields: [shopping_list_id], references: [id], onDelete: Cascade)

  @@map("shopping_list_cards")
}

model ShoppingListShares {
  id               String        @id @default(uuid(7)) @db.Uuid
  user_id          String        @db.Uuid
  user             Users         @relation(fields: [user_id], references: [id], onDelete: Cascade)
  shopping_list_id String        @db.Uuid
  shopping_list    ShoppingLists @relation(fields: [shopping_list_id], references: [id], onDelete: Cascade)

  @@map("shopping_list_shares")
}

generator client {
  provider        = "prisma-client"
  output          = "../prisma/generated"
  previewFeatures = ["queryCompiler", "driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model NewsLetterSubscriptions {
  id         String   @id @default(uuid(7)) @db.Uuid
  email      String   @unique
  created_at DateTime @default(now())

  @@map("newsletter_subscriptions")
}

model Users {
  id                String              @id @default(uuid(7)) @db.Uuid
  username          String              @db.VarChar(30) // Public display name
  email             String              @unique
  password          String // Hashed
  jwt_id            Bytes // JWT ID for token revocation
  master_key        Bytes // Encrypted master key (from application key, derivated from application secret)
  public_key        Bytes // Public key for encryption
  private_key       Bytes // Private key for decryption; Encrypted with master key
  created_at        DateTime            @default(now())
  updated_at        DateTime            @updatedAt
  avatars           Avatars?
  folders           Folders[]
  files             Files[]
  EmailVerification EmailVerification[]

  @@map("users")
}

model EmailVerification {
  id         String   @id @default(uuid(4)) @db.Uuid
  user_id    String   @db.Uuid
  user       Users    @relation(fields: [user_id], references: [id], onDelete: Cascade)
  created_at DateTime @default(now())
  expires_at DateTime

  @@map("email_verification")
}

model ServerFiles {
  id        String   @id @default(uuid(7)) @db.Uuid
  s3_key    String   @unique @db.Uuid
  checksum  String   @db.VarChar(64) // SHA-256 checksum for file integrity
  mime_type String?  @db.VarChar(50) // Optional MIME type for the file
  file_key  Bytes // Encrypted file key (from master key)
  iv        Bytes // Initialization vector for encryption
  auth_tag  Bytes // Authentication tag for encryption
  size      Int // Size in bytes
  avatar    Avatars?
  files     Files[]

  @@map("server_files")
}

model Avatars {
  user_id        String      @id @db.Uuid
  user           Users       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  server_file_id String      @unique @db.Uuid
  server_file    ServerFiles @relation(fields: [server_file_id], references: [id], onDelete: Cascade)

  @@map("avatars")
}

enum FolderTypes {
  MEDIA

  @@map("folder_types")
}

model Folders {
  id         String       @id @default(uuid(7)) @db.Uuid
  user_id    String       @db.Uuid
  user       Users        @relation(fields: [user_id], references: [id], onDelete: Cascade)
  folder_key Bytes // Encrypted folder key (from master key)
  name       String?      @db.VarChar(100) // Optional name for root folders
  type       FolderTypes? // Optional type for special folders (e.g., media)
  parent_id  String?      @db.Uuid // Null for root folders
  created_at DateTime     @default(now())
  updated_at DateTime     @updatedAt
  parent     Folders?     @relation("folder_hierarchy", fields: [parent_id], references: [id], onDelete: Cascade)
  children   Folders[]    @relation("folder_hierarchy")
  files      Files[]

  @@unique([name, parent_id]) // Ensure unique folder names per parent
  @@unique([user_id, type]) // Ensure unique folder names per user and type
  @@map("folders")
}

model Files {
  id        String      @id @default(uuid(7)) @db.Uuid
  user_id   String      @db.Uuid
  user      Users       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  file_id   String      @db.Uuid
  file      ServerFiles @relation(fields: [file_id], references: [id], onDelete: Cascade)
  name      String      @db.VarChar(100)
  folder_id String?     @db.Uuid // Null for root files
  folder    Folders?    @relation(fields: [folder_id], references: [id], onDelete: Cascade)

  @@unique([name, folder_id]) // Ensure unique file names per folder
  @@map("files")
}

// model ShoppingLists {
//   id      String               @id @db.VarChar(36)
//   user_id String               @db.VarChar(36)
//   user    Users                @relation(fields: [user_id], references: [id], onDelete: Cascade)
//   key     Bytes // Encrypted shopping list key (from master key)
//   items   ShoppingListItems[]
//   cards   ShoppingListCards[]
//   shares  ShoppingListShares[]
//
//   @@map("shopping_lists")
// }
//
// model ShoppingListItems {
//   id               Int           @id @default(autoincrement())
//   shopping_list_id String        @db.VarChar(36)
//   shopping_list    ShoppingLists @relation(fields: [shopping_list_id], references: [id], onDelete: Cascade)
//   name             String        @db.VarChar(100)
//   quantity         Int
//   unit             String        @db.VarChar(20) // e.g., "kg", "pcs"
//   completed        Boolean       @default(false)
//
//   @@map("shopping_list_items")
// }
//
// model ShoppingListCards {
//   id               String        @id @db.VarChar(36)
//   shopping_list_id String        @db.VarChar(36)
//   shopping_list    ShoppingLists @relation(fields: [shopping_list_id], references: [id], onDelete: Cascade)
//   name             String        @db.VarChar(100) // Name of the card
//   value            String        @db.VarChar(100) // Value of the card (e.g., a code or identifier)
//
//   @@map("shopping_list_cards")
// }
//
// model ShoppingListShares {
//   user_id          String        @db.VarChar(36)
//   user             Users         @relation(fields: [user_id], references: [id], onDelete: Cascade)
//   shopping_list_id String        @db.VarChar(36)
//   shopping_list    ShoppingLists @relation(fields: [shopping_list_id], references: [id], onDelete: Cascade)
//   key              Bytes // Encrypted shopping list key (from public key, decrypted with private key)
//
//   @@id([user_id, shopping_list_id])
//   @@map("shopping_list_shares")
// }
